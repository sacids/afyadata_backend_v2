<!-- Chart.js (CDN) -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

<script language="javascript">
    function initData() {
        const current_data = JSON.parse(document.getElementById('current-data').textContent || "[]");
        const forms = JSON.parse(document.getElementById('children-forms').textContent || "[]");

        return {
            title: current_data.title,
            subtitle: current_data.form_title,
            description: current_data.form_title,
            parentId: current_data.id,
            activeFormId: current_data.id,
            currentData: current_data,
            forms: forms,
            data_instance: current_data.form_data,
            tabId: 'information',
            viewMode: '',

            loading: false,
            postUrl: "",
            csrfToken: "{{ csrf_token|escapejs }}",

            form_cols: [],
            form_data: [],
            dt: null,

            loadData(form_id) {
                this.activeFormId = current_data.id;
                this.currentData = current_data;
                this.data_instance = current_data.form_data;
                this.tabId = 'information';
                this.viewMode = '';
            },

            initDataTable() {
                const $table = $('#datatable_form');
                if (!$table.length) return;

                // guard: avoid init with no columns
                if (!Array.isArray(this.form_cols) || this.form_cols.length === 0) return;

                // destroy safely but keep the table structure
                if ($.fn.dataTable.isDataTable($table)) {
                    $table.DataTable().clear().destroy();
                }

                // rebuild thead so headers match dynamic cols
                const thead = `<tr>${this.form_cols.map(c => `<th>${this.prettyHeader(c)}</th>`).join('')
                    }</tr>`;
                $table.find('thead').html(thead);
                $table.find('tbody').empty();

                const columns = this.form_cols.map((_, idx) => ({
                    data: idx,
                    defaultContent: "",
                }));

                this.dt = $table.DataTable({
                    data: this.form_data || [],
                    columns,
                    processing: false,
                    autoWidth: false,
                    scrollX: false,
                    pageLength: 13,
                    dom: `
                        <"flex justify-between items-center py-2 border-b text-sm"
                            <"flex gap-2 items-center"B>
                            <"flex items-center"p>
                        >
                        t
                    `,
                    language: {
                        search: "",
                        info: "_PAGE_ of _PAGES_",
                        emptyTable: "No data available",
                    },
                    buttons: [],
                });

                //make rows clickable (redirect to Django view)
                const self = this;
                $('#datatable_form tbody').off('click').on('click', 'tr', function () {
                    const rowData = self.dt.row(this).data();
                    if (!rowData) return;

                    // redirect to instance page
                    window.location.href = `/projects/forms/${rowData[0]}/data/instance`; // change to your URL
                });

                // UX: show pointer cursor on rows
                $('#datatable_form tbody').addClass('cursor-pointer');
            },

            rebuildDataTable() {
                // Rebuild whenever you change cols/data
                this.initDataTable();
            },

            prettyHeader(key) {
                // Optional: convert snake_case to Title Case
                return String(key)
                    .replace(/_/g, " ")
                    .replace(/\b\w/g, c => c.toUpperCase());
            },

            //show chart
            showChart(form_id) {
                const form = this.forms.find(f => String(f.id) === String(form_id));
                if (!form) return;

                this.activeFormId = form.id;
                this.viewMode = 'chart';
                this.tabId = '';
                this.$nextTick(() => {
                    this.loadChart(this.activeFormId);
                    this.loadFormDefinition(this.activeFormId);
                });
            },

            showMap() {
                this.viewMode = 'map';
                this.tabId = '';
                this.$nextTick(() => this.renderMap());
            },

            async loadTable(form_id) {
                const form = this.forms.find(f => String(f.id) === String(form_id));
                if (!form) return;

                this.activeFormId = form.id;
                this.title = form.title || "";
                this.description = form.description || "";
                this.viewMode = 'table';
                this.tabId = '';

                fetch(`/projects/forms/${this.activeFormId}/data?parent_id=${this.parentId}`)
                    .then(response => response.json())
                    .then(data => {
                        this.form_cols = data.cols;
                        this.form_data = data.data;

                        //rebuild the table
                        this.rebuildDataTable();
                    });
            },

            exportData(form_id) {
                window.location.href = `/projects/forms/${form_id}/data/export`;
            },

                        //load form_defn
            form_defn: {},
            async loadFormDefinition(form_id) {
                this.activeFormId = form_id;

                fetch(`/projects/forms/${form_id}/definition`)
                    .then(response => response.json())
                    .then(data => {
                        this.form_defn = data.cols;
                    });
            },

            // rendering charts
            loading: false,
            message: '',
            messageType: 'success',

            chart: null,
            chartType: 'bar',

            lastPayload: {},
            lastResponse: { labels: [], data: [] },

            // main form state
            form: {
                x_axis: null,
                y_axis: null,
                agg: 'count',
                date_from: '',
                date_to: '',
            },

            // simple UI filters mapped to JSON keys
            filters: {},
            stats: { points: 0, total: 0, max: 0, min: 0 },

            resetFilters() {
                this.form.date_from = '';
                this.form.date_to = '';
            },

            buildPayload() {
                const f = {};

                const payload = {
                    parent_id: this.parentId,
                    x_axis: this.form.x_axis,
                    agg: this.form.agg,
                    y_axis: this.form.agg === 'count' ? null : this.form.y_axis,
                    filters: f,
                    date_from: this.form.date_from || null,
                    date_to: this.form.date_to || null,
                };

                this.lastPayload = payload;
                return payload;
            },

            async loadChart(form_id) {
                // basic validation
                if (this.form.agg !== 'count' && !this.form.y_axis) {
                    this.messageType = 'error';
                    this.message = 'Please select a numeric Y-axis field for this aggregation.';
                    return;
                }

                this.loading = true;
                this.message = '';
                this.subtitle = 'Loading chart data…';
                this.postUrl = `/projects/forms/${form_id}/data/charts}`;

                try {
                    const payload = this.buildPayload();

                    const res = await fetch(this.postUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': this.csrfToken,
                        },
                        body: JSON.stringify(payload)
                    });

                    const data = await res.json();
                    if (!res.ok) {
                        throw new Error(data.error || 'Request failed');
                    }

                    this.lastResponse = data;
                    this.subtitle = `${data.agg.toUpperCase()} by ${data.x_axis}${data.y_axis ? (' → ' + data.y_axis) : ''}`;

                    this.computeStats(data.data || []);
                    this.draw(data.labels || [], data.data || []);

                    this.messageType = 'success';
                    this.message = 'Chart updated successfully.';
                } catch (err) {
                    this.messageType = 'error';
                    this.message = err.message || 'Choose options and generate.';
                    this.subtitle = 'Choose options and generate.';
                } finally {
                    this.loading = false;
                }
            },

            computeStats(arr) {
                const nums = (arr || []).map(v => Number(v || 0));
                const total = nums.reduce((a, b) => a + b, 0);
                const max = nums.length ? Math.max(...nums) : 0;
                const min = nums.length ? Math.min(...nums) : 0;

                this.stats = {
                    points: nums.length,
                    total: total,
                    max: max,
                    min: min,
                };
            },

            draw(labels, series) {
                const ctx = document.getElementById('chartCanvas');

                if (this.chart) {
                    this.chart.destroy();
                }

                this.chart = new Chart(ctx, {
                    type: this.chartType,
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Value',
                            data: series,
                            backgroundColor: '#800000',   // ← maroon bars
                            borderColor: '#660000',       // slightly darker border
                            borderWidth: 1,
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            legend: { display: false },
                            tooltip: { enabled: true }
                        },
                        scales: {
                            x: {
                                ticks: { maxRotation: 0, autoSkip: true }
                            },
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            },

            redraw() {
                // redraw with current response data without refetching
                this.draw(this.lastResponse.labels || [], this.lastResponse.data || []);
            },

            map: null,
            markersLayer: null,

            renderMap() {
                this.$nextTick(() => {
                    // 1) Create map ONCE
                    if (!this.map) {
                        this.map = L.map('mapContainer').setView([-6.40177, 34.99269], 6);

                        const tileUrl = 'https://tile.openstreetmap.org/{z}/{x}/{y}.png';
                        const attribution = '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>';

                        L.tileLayer(tileUrl, {
                            maxZoom: 19,
                            attribution: attribution,
                        }).addTo(this.map);

                        // layer group to manage markers (easy clear/reload)
                        this.markersLayer = L.layerGroup().addTo(this.map);

                        // extra attribution
                        this.map.attributionControl.addAttribution(
                            'Sacids Foundation for One Health &copy; <a href="#">Afyadata</a>'
                        );
                    } else {
                        // 2) When showing map again, just fix sizing
                        this.map.invalidateSize();
                    }

                    // 3) Load points each time Map is opened (or you can cache if you want)
                    this.loadMapPoints();
                });
            },

            loadMapPoints() {
                if (!this.map || !this.markersLayer) return;

                // clear old markers so they don't stack
                this.markersLayer.clearLayers();

                // IMPORTANT: use a URL that exists; if you have active form id use it
                const formId = this.activeFormId; // your Alpine state
                if (!formId) return;

                fetch(`/projects/forms/${formId}/data/points?parent_id=${this.parentId}`)
                    .then(r => r.json())
                    .then(points => {
                        if (!Array.isArray(points)) return;

                        const bounds = [];

                        points.forEach(p => {
                            const lat = Number(p.lat);
                            const lng = Number(p.lng);
                            if (!Number.isFinite(lat) || !Number.isFinite(lng)) return;

                            const marker = L.marker([lat, lng]).addTo(this.markersLayer);

                            const popupHtml = `
                                <strong>${p.title || 'No title'}</strong><br/>
                                UUID: ${p.uuid || ''}<br/>
                                Lat: ${lat.toFixed(5)}, Lng: ${lng.toFixed(5)}<br/>
                                Created: ${p.created_at || ''}<br/>
                                ${Object.keys(p.form_data || {}).map(key => `${key}: ${p.form_data[key] || ''}`).join('<br/>')}
                            `;

                            marker.bindPopup(popupHtml);
                            bounds.push([lat, lng]);
                        });

                        if (bounds.length > 0) {
                            this.map.fitBounds(bounds, { padding: [20, 20] });
                        }
                    })
                    .catch(err => console.error("Error loading form points:", err));
            },

        }
    }
</script>